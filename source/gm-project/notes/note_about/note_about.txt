# Upset 3D

## About
The U3D system is a collection of classes and elements that work together
to provide the base for 3D game development. This includes a rendering
pipeline, basic collision system, camera management, and other related
3D systems.

The systems are created very generically and are intended to be inherited
and expanded upon per-game to better accomodate the specific game's needs.
However, a basic 3D game should be completely doable with just the included
systems.

## GameMaker Settings
The garbage collector should be **enabled**. Most elements attempt to auto-manage themselves
but there are some cases where this is not possible due to the inability to determine if
the specified structure is generated by the user or the system and thus it errs on the side
of NOT cleaning up the structure.

The legacy 'copy-on-write' functionality for arrays should be **disabled**. Arrays
are directly written to through functions throughout this system.

## Setters / Getters
Setter and getter functions are defined for a reason and they should be used when available.
If a class has a setter it is either because some extra processing is necessary when
changing a value or it is expected to in the future. Setting variables directly when
they have an explicit setter can result in crashes and/or undefined behavior.

Getters are similar in that they will generally return a **copy** of the value you are
looking for. This is to prevent accidentally modifying the value in
the class without going through a setter. Getters can often be overlooked if you treat the 
variable as static and do not change it outside of a setter. This is NOT always the
case, however, as a number of elements are 'calculated when accessed' instead of
'calculated when set'. When in doubt, use the getter.

As an example, with modifying the position of a `Node`, executing something as simple as 
`node.position.x = 10;` would cause a number of issues as it would not tell the system
to update the rendering matrix, any attached nodes that the node moved, or any animation 
systems to update bone attachments. Instead, either of the following would be acceptable:

Example A:
```
node.set_position(vec(10, node.position.y, node.position.z)); // Access position directly, but without changing it
```

Example B:
```
var position_new = node.get_position(); // Fetch a copy of the position to modify
position_new.x = 10; // Modify the copy
node.set_position(position_new); // Assign the new updated position
```

## Initializing the Systems
There are multiple controller systems that can be generated in order to provide specific
functionality. Each system is stand-alone and, while they work together, they
are not reliant on each-other.

If you want the 3D rendering system, you would create the `obj_render_controller`.
Likewise, if you want the 3D collision system then you would create the
`obj_collision_controller`.

The common element that ties systems together are 3D Bodies. Everything in 3D
space, whether that be a visual element or collidable element, will be represented
by a `Body`. These bodies can be attached to each relevant system you wish to
use and the system will start managing it.

## Design Concepts
The entire U3D system is designed around a *passive signaling* system. Passive
systems are clean to use, quicker to process, and greatly reduce the potential
repeated wasted processing. However, they require a bit of extra setup and
cleanup to use.

You can think of this system similar to GameMaker's event system, only in that
you manually specify the event as a method. As an example, instead of manually checking if
there is a collision every step for a body, you can instead write a method that
handles what to do *when* there is a collision and attach it to the collision system.
The system will then call the method, like an event, when it detects a collision.

All this is done through the `Signal` class and every class that uses signals will
have a section detailing what signals are available and can be attached.

## Physics Note
The U3D system does **not** handle physics! It can handle collision detection and 
the system will provide details about each collision, however the method to *handle*
the collisions must be implemented manually.

## U3DObjects
Almost every class in the U3D system inherits from `U3DObject`. U3DObjects come equipped
with `Signaler`s, a `Super` handler, and numerous other memory-related functions. If you
create an instance of anything via the `new` operator in the U3D system, you **must**
manually call `free()` on that instance before deleting it or you will have a memory leak.

If a U3D instance is generated by the system itself, for example a `Model` being generated
by the `GLTFBuilder`, you can safely assume that the system will automatically clean up
the instance when no longer needed and calling `free` on these automatically generated
instances is unnecessary UNLESS the generating script specifically states otherwise.

If you wish for an U3DObject to be auto-managed by another instance you can mark
your instance to start counting references by calling the local function
`generate_unique_hash()`. After calling this function, any instance you attach it to
will start tracking references and the instance will be auto-freed once all
references are destroyed. The above function must be called before attaching
the instance to anything else and it **must** be attached to at least one other
instance before tracking will begin.

## Macros / Globals
There are a number of macros and global properties that can be referenced
throughout the system. A number of them, specifically the `U3D` global
struct, can be found in `scr_u3d_init`.

Most global settings, however, are defined as static variables inside of
the relevant class. As an example, if you wish to enable wireframe primitive
generation for debugging then you must toggle it through the class `Primitive`
via `Primitive.GENERATE_WIREFRAMES=true`. 

If a class has a static global property such as above, you can safely assume
that it will be automatically initialized for you at game start; you do not need
to instantiate a version of the class first.

## Compatability Mode

**Note:** Compatability mode is experimental fallback and NOT guaranteed to work!

### Rendering Pipeline
Some platforms do not support rendering to multiple textures at the same time so,
in these cases, the renderer is switched into 'compatability mode'. This means that
each texture has to be rendered to separately which also means that every model now
has to render multiple times. This is slower, especially with skeletal models, however
the fragment aspect is still culled with the previous depth-buffer and all lighting
passes still render the same as before.

A number of platforms seem to also have issues sampling from a texture pulled from
the depth buffer which means a number of effects (like SSAO) will not be available.
As such, you cannot expect all features to be available when in compatability mode.

### Rendering Buffers
Some platforms that use compatability mode, such as the GX export, require surfaces
to be in the dimension of 2^n. However, the rendering 'window' in the browser may not
be an appropriate size. The renderer will automatically scale the buffers to a proper
2^n resolution that is equal to or larger than your rendering output and then crop the
final result down to the nearest edge. Note, this is only true for the CameraView class.

For example, if you are rendering at 1280x720 in the web browser, the rendering buffers
will need to scale up to 2048x1024. Because of this, your FOV may NOT appear the same as
when rendering on regular targets and may need to be adjusted in these cases.

If you design around these limitations then you shouldn't have an issue.

### Shaders
Effectively any platform that requires 'compatability mode' will compile down to GLSES
rather than HLSL or GLSL. The included shaders accomodate some special syntax requirements
for GLSES though GameMaker's compile-time defines. If you write your own custom shaders
you will need to handle compatability mode yourself by checking if the shader was compiled
as GLSLES.

### Mixed Rendering
Because compatability mode requires re-rendering a lot of data, moreso than the regular
render mode, it is suggested that, for performance reasons, the translucent pass is
**not** used unless absolutely necessary. It is best that you don't use translucent materials
but, if this is absolutely necessary, the "mixed" rendering mode can be used instead and
translucent materials will be rendered with a dither which gives the illusion of 
translucency at the cost of quality.