/// @about
///	Very simple garbage collection for U3DObject reference clean-up. Added to
///	allow 'dangling references' until the end of the frame since we can't technically
/// track every literal reference of an instance. In short, it prevents generating
/// an instance and accidentally immediately auto-cleaning it before it gets passed
/// and tracked by something else.

/// @signals
///		"cleaned_ref" (count)		- Thrown when >=1 references were cleaned, providing the number cleaned

/// @note	The instance of this object should NOT be destroyed but, if it is, it will
///			instantly clean up all remaining references (which could be slow).

/// @note	Instances will only be tracked if generated by underlying U3D systems or if
///			an instance explicitly has `generate_unique_hash()` called on it.

reference_tracker = {};		// Contains all pending references
reference_array = [];		// Contains last generated array of references (must be cleaned before a new one is added)
max_process_time = 1;		// Maximum time spent (in ms) per frame cleaning up references (must be >= 1)
max_reference_count = 512;	// Maximum number of references allowed before the system bulk-frees to catch up
signaler = new Signaler();

/// @desc	Adds a reference to be checked for GC
function add_ref(instance){
	reference_tracker[$ instance.hash] = instance;
}

/// @desc	Process a batch of reference cleanups. Can be manually called without issue.
function process(){
	var time_start = current_time;
	// Generate the reference array if needed:
	if (array_length(reference_array) <= 0){
		if (struct_names_count(reference_tracker) <= 0)
			return;
		
		reference_array = struct_get_values(reference_tracker);
		reference_tracker = {};
	}
	
	var time_remaining = max_process_time - (current_time - time_start);
	if (time_remaining <= 0)
		return;
	
	var loop = array_length(reference_array);
	var i = 0;
	var time_max = (loop >= max_reference_count ? infinity : max_process_time);
	for (;i < loop; ++i){
		if (i % 8 == 0 and current_time - time_start >= time_max)
			break;
		
		var u3d_instance = reference_array[i];
		if (not U3DObject.get_is_valid_object(u3d_instance))
			continue;
		
		var hash = u3d_instance.hash;
		if (is_undefined(hash)) // Static resource (or already cleaned)
			continue;
			
		if (is_undefined(U3D.MEMORY[$ hash])) // Invalid resource
			continue;
		
		if (U3D.MEMORY[$ hash].count != 0) // Was re-referenced before clean-up; skip
			continue;
		
		// All good, wipe the reference:
		struct_remove(U3D.MEMORY, hash);
		u3d_instance.signaler.signal("cleanup");	// Throw a signal for any additional required cleanup
		u3d_instance.hash = undefined;				// Wipe hash as it is now dereferenced
		u3d_instance.free();						// Free the resources attached to the instance
	}
	
	if (i >= loop)
		reference_array = [];
	else if (i > 0)
		array_delete(reference_array, 0, i);
	
	signaler.signal("cleaned_ref", [i]);
}

/// @desc	Forces a completely full wipe of all pending references:
function process_full(){
	var time_max = max_process_time;
	max_process_time = infinity;
		// Call twice, once to clean any remaining array values and once
		// to generate a new array and clean that.
	process();
	process();
	max_process_time = time_max;
}