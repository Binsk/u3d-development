# Upset 3D

## About
The U3D system is a collection of classes and elements that work together
to provide the base for 3D game development. This includes a rendering
pipeline, basic collision system, camera management, and other related
3D systems.

The systems are created very generically and are intended to be inherited
and expanded upon per-game to better accomodate the specific game's needs.
However, a basic 3D game should be completely doable with just the included
systems.

## Initializing the Systems
There are multiple systems that can be generated in order to provide specific
functionality. Each system is stand-alone and, while they work together, they
are not reliant on each-other.

If you want the 3D rendering system, you would created the `obj_render_controller`.
Likewise, if you want the 3D collision system then you would create the
`obj_collision_controller`.

The common element that ties systems together are 3D Bodies. Everything in 3D
space, whether that be a visual element or collidable element, will be represented
by a `Body`. These bodies can be attached to each relevant system you wish to
use and the system will start managing it.

## Design Concepts
The entire U3D system is designed around a *passive signaling* system. Passive
systems are clean to use, quicker to process, and greatly reduce the potential
repeated wasted processing. However, they require a bit of extra setup and
cleanup to use.

You can think of this system similar to GameMaker's event system, only in that
you manually specify the event as a method. As an example, instead of manually checking if
there is a collision every step for a body, you can instead write a method that
handles what to do *when* there is a collision and attach it to the collision system.
The system will then call the method, like an event, when it detects a collision.

All this is done through the `Signal` class and every class that uses signals will
have a section detailing what signals are available and can be attached.

## Physics Note
The U3D system does **not** handle physics! It can handle collision detection and 
the system will provide details about each collision, however the method to *handle*
the collisions must be implemented manually.

## Garbage Collection
The garbage collector should be **enabled**. Most elements attempt to auto-manage themselves
but there are some cases where this is not possible due to the inability to determine if
the specified structure is generated by the user or the system and thus it errs on the side
of NOT cleaning up the structure.

## U3DObjects
Almost every class in the U3D system inherits from U3DObject(). U3DObjects come equipped
with signalers, a 'super' handler, and numerous other memory-related functions. If you
create an instance of anything via the `new` operator in the U3D system, you **must**
manually call `free()` on that instance before deleting it or you will have a memory leak.

If a U3D instance is generated by the system itself, for example a `Model` being generated
by the `GLTFBuilder`, you can safely assume that the system will automatically clean up
the instance when no longer needed and calling `free` on these automatically generated
instances is unnecessary UNLESS the generating script specifically states otherwise.

If you wish for an U3DObject to be auto-managed by another instance you can mark
your instance to start counting references by calling the local function
`set_unique_hash()`. After calling this function, any instance you attach it to
will start tracking references and the instance will be auto-freed once all
references are destroyed.