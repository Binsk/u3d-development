/// @about
/// The GLTFBuilder is an extension of the GLTFLoader that provides functions for
/// constructing in-game meshes, materials, and the like out of the buffer data
/// contained within. Unless you are doing something very specific and custom, 
/// you should load in GLTF / GLB files with this rather than the GLTFLoader().
///
/// All structures generated by the builder will be automatically freed once no
/// references of them exist anymore.
///
/// @note	The GLTFBuilder does NOT support the full glTF spec and all of its
///			nuances. It was designed to handle general-case usage of Blender exports.
///
/// @note	Skeletal animation only supports vertex skinning! Some glTF models can
///			specify morphing mesh positions directly through nodes, this is NOT supported!
///
/// @note	For supported KHR extensions, check the GLTFLoader header.

/// @todo	Implement passing a buffer directly to allow loading encrypted model files
/// 		and similar such abilities.
/// 
function GLTFBuilder(name="", directory="") : GLTFLoader() constructor {
	#region PROPERTIES
	self.name = name;
	material_class = MaterialSpatial; // The material class to use when generating materials
	#endregion
	
	#region METHODS
	/// @desc	Specify a material class to use when generating materials. It must be a 
	///			child of MaterialSpatial. This can allow generating a model with a special
	///			material that may have special processing requirements.
	function set_material_class(class=MaterialSpatial){
		material_class = class;
	}
	
	/// @desc	Given a node index, returns the final transform of it, post-multiplied
	///			against its parents all the way up to the root.
	function get_node_transform(node_index){
		var node_array = (json_header[$ "nodes"] ?? []);
		if (node_index < 0 or node_index >= array_length(node_array))
			return matrix_build_identity();
		
		var node = node_array[node_index];
		var transform = node[$ "matrix"];
			// Might have manual transforms:
		if (is_undefined(transform)){
			var translation = (node[$ "translation"] ?? [0, 0, 0]);
			var rotation = (node[$ "rotation"] ?? [0, 0, 0, 1]);
			var scale = (node[$ "scale"] ?? [1, 1, 1]);

			var T = matrix_build_translation(vec(translation[0], translation[1], translation[2]));
			var R = matrix_build_quat(quat(rotation[0], rotation[1], rotation[2], rotation[3]));
			var S = matrix_build_scale(vec(scale[0], scale[1], scale[2]));

			transform = matrix_multiply_post(T, R, S);
		}
		
		for (var i = array_length(node_array) - 1; i >= 0; --i){
			var parent_node = node_array[i];
			var child_array = (parent_node[$ "children"] ?? []);
			if (array_contains(child_array, node_index))
				return matrix_multiply(transform, get_node_transform(i));
		}
		
		return transform;
	}
	
	/// @desc	Returns the total number of meshes in the loaded model.
	function get_mesh_count(){
		return array_length(json_header[$ "meshes"] ?? []);
	}
	
	/// @desc	Given a mesh index in the file, returns the number of primitives
	///			required to define the mesh.
	function get_primitive_count(mesh_index){
		if (not in_range(mesh_index, 0, get_mesh_count() - 1)) // Invalid mesh
			return 0;
		
		return array_length(json_header.meshes[mesh_index][$ "primitives"] ?? []);
	}
	
	/// @desc	Given a primitive, generates a VertexFormat that will correctly
	///			contain all the data specified by the model file.
	function get_primitive_format(mesh_index, primitive_index){
/// @stub	So this is a pain as GameMaker doesn't support dynamically compiled shaders (hopefully in GMRT?).
///			Having an option for EVERY combination would be hell so instead the primary elements will be
///			required (and auto-filled if missing from the model). Animation elements will be conditional as
///			they are costly both to import (even w/ placeholders) and render.
///			A better way will be added later; likely through a library if needed or a fake module system of sorts.

		var base = [VERTEX_DATA.position, VERTEX_DATA.color, VERTEX_DATA.texture, VERTEX_DATA.normal, VERTEX_DATA.tangent];
		if (get_animation_track_count() > 0)
			base = array_concat(base, [VERTEX_DATA.bone_indices, VERTEX_DATA.bone_weights]);

/// @stub	Add extra channel data for morph targets

		return VertexFormat.get_format_instance(base);
	}
	
	/// @desc	Returns an array of animation track names defined for this model.
	///			Animations are NOT guaranteed to have names, so if an animation is found
	///			but no name exists its name will be specified as 'undefined'
	function get_animation_track_names(){
		// Check if there is an 'animation' section
		if (is_undefined(json_header[$ "animations"]))
			return [];
			
		var animation_array = json_header[$ "animations"];
		var array = array_create(array_length(animation_array), undefined);
		for (var i = array_length(array) - 1; i >= 0; --i)
			array[i] = animation_array[i][$ "name"];
		
		return array;
	}
	
	/// @desc	Return the number of animation tracks available for this model.
	function get_animation_track_count(){
		if (is_undefined(json_header[$ "animations"]))
			return 0;
		
		return array_length(json_header[$ "animations"]);
	}
	
	/// @desc	Returns the number of skins defined for this model; used with 
	///			animation tracks.
	function get_skin_count(){
		if (is_undefined(json_header[$ "skins"]))
			return 0;
		
		return array_length(json_header[$ "skins"]);
	}
	
	/// @desc	Given a node ID, generates an array of node IDs attached to it
	///			including itself all the way down the tree to the last grandchild.
	/// @param	{real}		node_id		index of the specific node to scan
	/// @param	{struct}	state		the current scan state; should be left empty when calling
	/// @return	{array}
	function get_node_list(node_id, state={}){
		var node = get_structure(node_id, "nodes");
		if (is_undefined(node))
			return [];
		
		if (not is_undefined(state[$ node_id]))
			return [];
			
		state[$ node_id] = true;
		
		var children = node[$ "children"];
		if (not is_undefined(children)){
			for (var i = array_length(children) - 1; i >= 0; --i)
				get_node_list(children[i], state);
		}

		return struct_get_names(state);
	}
	
	/// @desc	Returns an array of all the node indices in a specific scene. If the scene
	///			specified is -1 then all nodes in the model are returned
	function get_scene_nodes(scene=-1){
		var node_array;
		var scene_data = get_structure(scene, "scenes");
		if (not is_undefined(scene_data)){
			if (not is_undefined(scene_data[$ "nodes"])){
				var narray = scene_data[$ "nodes"];
				var array = [];
				for (var i = array_length(narray) - 1; i >= 0; --i)
					array_push(array, get_node_list(narray[i]));
			
				node_array = array_flatten(array);
			}
		}
		else{
			node_array = json_header[$ "nodes"];
			var array = array_create(array_length(node_array));
			for (var i = array_length(node_array) - 1; i >= 0; --i)
				array[i] = i;
			
			node_array = array;
		}
		
		return node_array;
	}
	
	/// @desc	Generates an array of spatial materials. Note that the materials
	///			will have dynamically-generated textures attached! Textures are re-used
	///			across generations to save memory, however materials are newly generated
	///			each time.
	function generate_material_array(){
		var material_data_array = json_header[$ "materials"];
		var material_array = array_create(array_length(material_data_array), undefined);
		var sprite_data_array = json_header[$ "images"];
		var texture_array = [];
		
		// First add new sprites to the system:
		for (var i = 0; i < array_length(sprite_data_array); ++i){
			var texture_hash = md5_string_utf8($"{self.load_directory}{self.name}_sprite_texture_{i}");
			var texture = U3DObject.get_ref_data(texture_hash);
			if (not is_undefined(texture)){ // Value already loaded
				array_push(texture_array, texture);
				continue;
			}
			
			var data = sprite_data_array[i];
			
			check_unsupported_extensions(data);
			
			var sprite;
			if (not is_undefined(data[$ "uri"])){ // External file, load normally
				if (not file_exists(load_directory + data.uri)){
					Exception.throw_conditional(string_ext("failed to find image [{0}].", [load_directory + data.uri]));
					continue;
				}
				
				texture = new Texture2D();
				texture.hash = texture_hash;	// Mark that this is a dynamic resource
				
				var label = load_directory + data.uri;
				sprite = sprite_add_ext(label, 1, 0, 0, true);
					// Track the sprite load so we assign it to the texture once loaded
				U3D_ASYNC.add_sprite_track(sprite, new Callable(texture, function(sprite, filepath){
					file_delete(filepath);
						// If the texture got freed at some point
					if (not U3DObject.get_is_valid_object(self) and sprite_exists(sprite)){
						sprite_delete(sprite);
						return;
					}
					set_texture(sprite_get_texture(sprite, 0));
					signaler.add_signal("cleanup", new Callable(self, sprite_delete, [sprite]));
				}, [sprite, label]));

				
				add_child_ref(texture);
				array_push(texture_array, texture);
				continue;
			}

			// Data buffer, must write to disk to re-load as PNG/JPG
			if (string_lower(data.mimeType) != "image/png" and string_lower(data.mimeType) != "image/jpeg"){
				Exception.throw_conditional(string_ext("unsupported mime type [{0}].", [data.mimeType]));
				continue;
			}

			var buffer = read_buffer_view(data.bufferView);
			if (is_undefined(buffer)){
				Exception.throw_conditional(string_ext("failed to read buffer view [{0}].", [data.bufferView]));
				continue;
			}

			// Save the image data to disk:
			texture = new Texture2D();
			texture.hash = texture_hash;	// Mark that this is a dynamic resource
			
			var label = $"__import_{texture_hash}";
			buffer_save(buffer, label);
			sprite = sprite_add_ext(label, 1, 0, 0, true);
				// Track the sprite load so we assign it to the texture once loaded
			U3D_ASYNC.add_sprite_track(sprite, new Callable(texture, function(sprite, filepath){
				file_delete(filepath);
					// If the texture got freed at some point
				if (not U3DObject.get_is_valid_object(self) and sprite_exists(sprite)){
					sprite_delete(sprite);
					return;
				}
				
				set_texture(sprite_get_texture(sprite, 0));
				signaler.add_signal("cleanup", new Callable(self, sprite_delete, [sprite]));
			}, [sprite, label]));
	
			buffer_delete(buffer);
			
			add_child_ref(texture);
			array_push(texture_array, texture);
		}
		
		// Next generate the material data:
		for (var i = 0; i < array_length(material_data_array); ++i){
			var material_hash = md5_string_utf8($"{self.load_directory}{self.name}_material_{i}");
			var material = U3DObject.get_ref_data(material_hash);
			if (not is_undefined(material)){
				material_array[i] = material;
				continue
			}
			
			var material_data = material_data_array[i];
			
			check_unsupported_extensions(material_data);
			
			var pbr_data = material_data[$ "pbrMetallicRoughness"]; // May not be set!
			// First, a quick check to see if we failed to load the sprite and fill w/ 'no texture'
			if (not is_undefined(pbr_data) and not is_undefined(pbr_data[$ "baseColorTexture"]) and is_undefined(texture_array[pbr_data[$ "baseColorTexture"]])){
				material_array[i] = U3D.RENDERING.MATERIAL.missing.duplicate();
				continue;
			}
			
				// Define a lambda function to auto-handle applying mipmap and filter settings
			function apply_texture_data(texture_id, texture_struct){
				var texture_data = get_structure(texture_id, "textures");
				if (is_undefined(texture_data[$ "sampler"]))
					return;

				var source = get_structure(texture_data[$ "sampler"], "samplers");
				if (is_undefined(source))
					return;
				
				// We don't have precise control here in GameMaker, so we choose some
				// 'close enough' values. Magic numbers come from glTF spec.
				var min_filter = source[$ "minFilter"];
				if (not is_undefined(min_filter)){
					if (min_filter == 9729) // Magic bytes for 'linear'
						texture_struct.set_tex_filter(tf_linear);
					else if (min_filter >= 9984){
						texture_struct.set_tex_mip_enable(true);
						texture_struct.set_tex_filter(min_filter >= 9985 ? tf_linear : tf_point);
						/// @note	glTF doesn't support anisotropic filtering; if desired it must be set manually
						///			or through the Texture2D.ANISOTROPIC_OVERRIDE_* values
					}
				}
				
					// Doesn't support reverse-wrap so we just allow wrapping for any value except clamp
				var texwrap = false;
				if ((source[$ "wrapS"] ?? 10497) != 33071 or (source[$ "wrapT"] ?? 10497) != 33071)
					texwrap = true;
				
				texture_struct.set_tex_repeat(texwrap);
			}
			
			// Defaults:
			var color_base = [1, 1, 1, 1];
			var color_texture = undefined;
			var pbr_base = [1, 1, 1];
			var pbr_texture = undefined;
			var normal_texture = undefined;
			var emissive_texture = undefined;
			var emissive_base = [1, 1, 1];
			var cull_mode = (material_data[$ "doubleSided"] ?? false) ? cull_noculling : cull_counterclockwise;
			var alpha_cutoff = (material_data[$ "alphaCutoff"] ?? 0.5);
			var is_translucent = false;
			
/// @stub	Add support for pulling texture texCoord properties in case textures are shared!
///			Should be added to the Texture2D class
			if (not is_undefined(pbr_data)){
				color_base = pbr_data[$ "baseColorFactor"] ?? color_base;
				// Albedo Texture
				if (not is_undefined(pbr_data[$ "baseColorTexture"])){
					var texture_index = get_structure(pbr_data[$ "baseColorTexture"].index, "textures").source;
					color_texture = texture_array[texture_index];
					apply_texture_data(pbr_data[$ "baseColorTexture"].index, color_texture);
				}
				// PBR Texture
				if (not is_undefined(pbr_data[$ "metallicRoughnessTexture"])){
					var texture_index = get_structure(pbr_data[$ "metallicRoughnessTexture"].index, "textures").source;
					pbr_texture = texture_array[texture_index];
					apply_texture_data(pbr_data[$ "metallicRoughnessTexture"].index, pbr_texture);
				}
				// PBR Factors (note, specular is always 1):
				if (not is_undefined(pbr_data[$ "roughnessFactor"]))
					pbr_base[PBR_COLOR_INDEX.roughness] = pbr_data[$ "roughnessFactor"];
				
				if (not is_undefined(pbr_data[$ "metallicFactor"]))
					pbr_base[PBR_COLOR_INDEX.metalness] = pbr_data[$ "metallicFactor"];
			}
			
			if (not is_undefined(material_data[$ "normalTexture"])){
				var texture_index = get_structure(material_data[$ "normalTexture"].index, "textures").source;
				normal_texture = texture_array[texture_index];
				apply_texture_data(material_data[$ "normalTexture"].index, normal_texture);
			}
			
			if (not is_undefined(material_data[$ "emissiveTexture"])){
				var texture_index = get_structure(material_data[$ "emissiveTexture"].index, "textures").source;
				emissive_texture = texture_array[texture_index];
				emissive_base = (material_data[$ "emissiveFactor"] ?? [1, 1, 1]);
				apply_texture_data(material_data[$ "emissiveTexture"].index, emissive_texture);
			}
			
			switch (material_data[$ "alphaMode"] ?? "OPAQUE"){
				case "OPAQUE":	// Effectively the same as "MASK" but doesn't allow transparency
					alpha_cutoff = 0.0;
				case "MASK":	// Alpha is either 0 or 1, this being determined by the alpha cutoff
					is_translucent = false;
					break;
				case "BLEND":	// Allows translucency
					is_translucent = true;
					break;
				default:
					Exception.throw_conditional($"invalid alphaMode [{material_data[$ "alphaMode"]}]");
			}
			
			material = new material_class();
			
			if (not is_undefined(color_texture))
				material.set_texture("albedo", color_texture);
			if (not is_undefined(pbr_texture))
				material.set_texture("pbr", pbr_texture);
			if (not is_undefined(normal_texture))
				material.set_texture("normal", normal_texture);
			if (not is_undefined(emissive_texture))
				material.set_texture("emissive", emissive_texture);
			
			material.scalar.albedo = color_base;
			material.scalar.pbr = pbr_base;
			material.scalar.emissive = emissive_base;
			material.cull_mode = cull_mode;
			material.alpha_cutoff = alpha_cutoff;
			material.render_stage = (is_translucent ? CAMERA_RENDER_STAGE.translucent : CAMERA_RENDER_STAGE.opaque);
			material.hash = material_hash;
			add_child_ref(material);
			
			/// @note	The material will auto-dereference the texture
			material_array[i] = material;
		}
		
/// @note	Textures will be kept in memory so long as this instance exists in case of 
///			generating / removing things back-to-back.
			
		return material_array;
	}
	
	/// @desc	Given a mesh and primitive index, attempts to generate a Primitive.
	///			The Primitive will contain the properties specified according to the 
	///			specified format. If the format contains values that are undefined by the
	///			model, the system will attempt to generate them (if possible) or fill them
	///			with 0 values. Returns 'undefined' if an error occurred.
	/// @param	{real}	mesh_index				index of the mesh to read from
	/// @param	{real}	primitive_index			index of the primitive to generate
	/// @param	{VertexFormat} vertex_format	vertex format to specify data layout and inclusion
	/// @param	{real}	transform=undefined		transform matrix to apply to each vertex position
	function generate_primitive(mesh_index, primitive_index, format, transform=undefined) {
		if (not in_range(mesh_index, 0, get_mesh_count() - 1))	// Invalid mesh index
			return undefined;
		
		if (not in_range(primitive_index, 0, get_primitive_count(mesh_index) - 1)) // Invalid primitive index
			return undefined;
		
		if (not is_instanceof(format, VertexFormat)){
			Exception.throw_conditional("invalid type, expected [VertexFormat]!");
			return undefined;
		}
		
		var primitive_hash = md5_string_utf8($"{self.load_directory}{self.name}_primitive_{mesh_index}{primitive_index}{format.get_hash()}{transform}");
		var primitive = U3DObject.get_ref_data(primitive_hash);
		if (not is_undefined(primitive))
			return primitive;
		
		var min_vec = get_data(["model_data", "minimum"], vec(infinity, infinity, infinity));		// Used to record generic vertex data
		var max_vec = get_data(["model_data", "maximum"], vec(-infinity, -infinity, -infinity));
		// Fetch our primitive header so we know what data we have:
		var primitive_header = json_header.meshes[mesh_index].primitives[primitive_index];
			// Check topology, we only support one type of many:
		if ((primitive_header[$ "mode"] ?? 4) != 4){
			var mode_labels = ["POINTS", "LINES", "LINE_LOOP", "LINE_STRIP", "TRIANGLES", "TRIANGLE_STRIP", "TRIANGLE_FAN"];
			Exception.throw_conditional(string_ext("unsupported topology type [{0}], expected [{1}]!", [mode_labels[primitive_header[$ "mode"] ?? 4], mode_labels[4]]));
			return undefined;
		}
		
		check_unsupported_extensions(primitive_header);

		if (not is_undefined(primitive_header[$ "targets"])){
/// @stub	Implement! This requires a whole new style of animation; must be able to combine w/ skeletal as well
			throw new Exception("unsupported primitive feature, [morph targets]!");
		}

		var accessor_index = primitive_header.indices;
		if (is_undefined(accessor_index)){ // We only support index definition through accessors
			Exception.throw_conditional("unsupported primitive definition, indices accessor required!");
			return undefined;
		}
		
		// Grab the accessor so we can fetch a list of vertex indices
		var primitive_accessor = get_structure(accessor_index, "accessors");
		
		if (is_undefined(primitive_accessor)){
			Exception.throw_conditional(string_ext("invalid accessor index [{0}]!", [accessor_index]));
			return undefined;
		}
	
		if ((primitive_accessor[$ "type"] ?? "UNKNOWN") != "SCALAR"){
			Exception.throw_conditional(string_ext("unsupported index type [{0}], expected type [SCALAR].", [primitive_accessor[$ "type"] ?? "UNKNOWN"]));
			return undefined;
		}
		
		check_unsupported_extensions(primitive_accessor);
		
		var vertex_index_array = read_accessor(accessor_index); // Array of integers pointing to vertex data indices
		if (is_undefined(vertex_index_array)){ // If anything goes wrong, throw a generic error
			Exception.throw_conditional(string_ext("failed to read accessor [{0}]!", [accessor_index]));
			return undefined;
		}

		#region BUILD ATTRIBUTE LOOKUP
		// Now we build array groups of attributes that match the vertex format for quick look-up
		// when building the mesh
		var vertex_index_count = array_length(vertex_index_array);
		var missing_data = [];	// Record which data is missing so we can spit a warning
		var primitive_map = {};
		var component_type_map = {};
		var map_size = 0;
		for (var i = array_length(format.vformat_array) - 1; i >= 0; --i){
			var array;
			var format_label = VertexFormat.get_vertex_data_gltf_label(format.vformat_array[i]);
			var accessor_index = primitive_header.attributes[$ format_label];
			
			if (is_undefined(accessor_index)){ // Mesh doesn't contain data we are requesting; fill w/ defaults
				array = array_create(vertex_index_count, VertexFormat.get_vertex_data_default(format.vformat_array[i]));
				array_push(missing_data, format_label);
			}
			else{
				array = read_accessor(accessor_index);
				component_type_map[$ format_label] = get_buffer_ctype_from_gltf_ctype(get_structure(accessor_index, "accessors").componentType);
			}
			
			primitive_map[$ format_label] = array;
			map_size = max(map_size, array_length(array));
		}
		#endregion
		
		if (array_length(missing_data) > 0)
			print_traced("WARNING", "primitive definition missing requested data ", string_replace_all(json_stringify(missing_data, false), "\"", "") + "!");
		
		// Build the primitive itself:
		var is_custom_transform = not is_undefined(transform);
		primitive = new Primitive(format);
		primitive.hash = primitive_hash;
		primitive.define_begin(map_size);
		
		var has_tangent_data = (format.get_has_data(VERTEX_DATA.position) and format.get_has_data(VERTEX_DATA.tangent) and format.get_has_data(VERTEX_DATA.texture)); // Used when auto-calculating tangents
		var loop = array_length(format.vformat_array);
		
		#region ARRAY PRE-ALOTMENT
		/// GameMaker has memory management issues w/ lots of arrays in a loop & arrays of this number
		/// are surprisingly slow to create; we are optimizing by manually re-using them.
		var vertex_array = array_create(3);
		var uv_array = array_create(3);
		var indices = array_create(3);
		var tangent = array_create(3);
		#endregion
		
		for (var i = 0; i < loop; ++i){
			var format_label = VertexFormat.get_vertex_data_gltf_label(format.vformat_array[i]);
			var array = primitive_map[$ format_label];
			var component_type = (component_type_map[$ format_label] ?? buffer_f32);
			
			for (var j = 0; j < vertex_index_count; ++j){
				var data = array[vertex_index_array[j]];
					// Colors can come in various datatypes; handle the integer versions
				#region COLOR DATA SPECIAL-HANDLING
				if (format.vformat_array[i] == VERTEX_DATA.color){
					var div_value = 0;
					if (component_type == buffer_u16)
						div_value = 65535;
					else if (component_type == buffer_u8)
						div_value = 255;
					
					data = (is_quat(data) ? quat_to_array(data) : vec_to_array(data));
					if (div_value > 0){
						for (var k = array_length(data) - 1; k >= 0; --k)
							data[k] /= div_value;
					}
						
					data = [make_color_rgb(data[0] * 255, data[1] * 255, data[2] * 255), array_length(data) > 3 ? data[3] : 1.0];
				}
				#endregion
				#region POSITION / NORMAL DATA SPECIAL-HANDLING
				else if (format.vformat_array[i] == VERTEX_DATA.position){
					if (is_custom_transform){
						var result = matrix_transform_vertex(transform, data.x, data.y, data.z, 1.0);
						data = vec(result[0], result[1], result[2]);
					}
					min_vec.x = min(min_vec.x, data.x);
					min_vec.y = min(min_vec.y, data.y);
					min_vec.z = min(min_vec.z, data.z);
					max_vec.x = max(max_vec.x, data.x);
					max_vec.y = max(max_vec.y, data.y);
					max_vec.z = max(max_vec.z, data.z);
				}
				else if (format.vformat_array[i] == VERTEX_DATA.normal and is_custom_transform){
					var result = matrix_transform_vertex(transform, data.x, data.y, data.z, 0.0);
					data = array_normalize([result[0], result[1], result[2]]);
				}
				#endregion
				#region TANGENT DATA SPECIAL-HANDLING
				else if (format.vformat_array[i] == VERTEX_DATA.tangent){
					var needs_auto_calculation = false;
					if (not is_quat(data)) // Blender exports as a vec4 for some reason? Not sure what w is for; it is always -1 or 1
						needs_auto_calculation = true;
					else
						data = vec_normalize(vec(data.x, data.y, data.z));
					
					if (vec_is_zero(data))
						needs_auto_calculation = true;
					
					// If possible, the tangent will be auto-calculated
					if (needs_auto_calculation){
						if (not has_tangent_data)
							throw new Exception("failed to auto-generate tangents, missing position and/or UV values!");
						
						// Tangents need the whole triangle to calculate, so we fetch the triangle points:
/// @todo	Lots of repeated calculations here, we could cache things so we only calculate this
///			once per face instead of once per vertex.
						indices[0] = j - (j % 3);
						indices[1] = j - (j % 3) + 1;
						indices[2] = j - (j % 3) + 2;
						
						/// @note	VertexFormat guarantees that normals / UVs will be completely defined before tangents
						vertex_array[0] = primitive.definition_data[$ VERTEX_DATA.position][indices[0]];
						vertex_array[1] = primitive.definition_data[$ VERTEX_DATA.position][indices[1]];
						vertex_array[2] = primitive.definition_data[$ VERTEX_DATA.position][indices[2]];
						uv_array[0] = primitive.definition_data[$ VERTEX_DATA.texture][indices[0]];
						uv_array[1] = primitive.definition_data[$ VERTEX_DATA.texture][indices[1]];
						uv_array[2] = primitive.definition_data[$ VERTEX_DATA.texture][indices[2]];
						// Calculate tangent:
						var e1 = [vertex_array[1][0] - vertex_array[0][0], vertex_array[1][1] - vertex_array[0][1], vertex_array[1][2] - vertex_array[0][2]];
						var e2 = [vertex_array[2][0] - vertex_array[0][0], vertex_array[2][1] - vertex_array[0][1], vertex_array[2][2] - vertex_array[0][2]];
						var duv1 = [uv_array[1][0] - uv_array[0][0], uv_array[1][1] - uv_array[0][1]];
						var duv2 = [uv_array[2][0] - uv_array[0][0], uv_array[2][1] - uv_array[0][1]];
						var f = 1.0 / (duv1[0] * duv2[1] - duv2[0] * duv1[1]);
						tangent[0] = f * (duv2[1] * e1[0] - duv1[1] * e2[0]);
						tangent[1] = f * (duv2[1] * e1[1] - duv1[1] * e2[1]);
						tangent[2] = f * (duv2[1] * e1[2] - duv1[1] * e2[2]);
						
						// if (vec_is_zero(tangent) or vec_is_nan(tangent))
						// 	tangent = VertexFormat.get_vertex_data_default(VERTEX_DATA.tangent);
							
						data = array_normalize(tangent);
					}
					else if (is_custom_transform){
						var result = matrix_transform_vertex(transform, data.x, data.y, data.z, 0.0);
						data = array_normalize([result[0], result[1], result[2]]);
					}
				}
				#endregion
				
				if (is_struct(data)){
					if (is_undefined(data[$ "w"]))
						data = vec_to_array(data);
					else
						data = quat_to_array(data);
				}
				
				primitive.define_set_data_raw(j, format.vformat_array[i], data, j == vertex_index_count - 1);
			}
		}
		
		primitive.define_end();
		
		add_child_ref(primitive);
		set_data(["model_data", "minimum"], min_vec);
		set_data(["model_data", "maximum"], max_vec);
		
		// Cleanup to make GameMaker free memory:
		missing_data = undefined;
		vertex_array = undefined;
		uv_array = undefined;
		indices = undefined;
		
		return primitive;
	}
	
	/// @desc	Given a mesh index, attempts to generate a Mesh. See generate_primitive for more
	///			specifics in regards to data handling.
	/// @param	{real}			index				index of the mesh in the glTF array
	///	@param	{VertexFormat}	format				vertex format to use when building the primitives
	/// @param	{bool}			apply_transforms	if true, applies node transforms directly to vertex buffers
	function generate_mesh(mesh_index, format, apply_transforms=true){
		var count = get_primitive_count(mesh_index);
		if (count <= 0)
			return undefined;
			
		var mesh_hash = md5_string_utf8($"{self.load_directory}{self.name}_mesh_{mesh_index}{format.get_hash()}{apply_transforms}");
		var mesh = U3DObject.get_ref_data(mesh_hash);
		if (not is_undefined(mesh))
			return mesh;
			
		var transform = undefined;
		// Calculate transform matrix for this mesh (if one exists and apply transforms is enabled)
		if (apply_transforms){
			var node_array = (json_header[$ "nodes"] ?? []);
			for (var i = array_length(node_array) - 1; i >= 0; --i){
				var node = node_array[i];
				if ((node[$ "mesh"] ?? -1) != mesh_index)
					continue;
				
				transform = get_node_transform(i);
				if (matrix_is_identity(transform))
					transform = undefined; // Unset as it allows faster model building
					
				break;
			}
		}
		var primitive_array = array_create(count, undefined);
		var is_invalid = false;
		var i;
		for (i = 0; i < count; ++i){
			var primitive = generate_primitive(mesh_index, i, format, transform);
			if (is_undefined(primitive)){
				is_invalid = true;
				break;
			}
			
			primitive_array[i] = primitive;
		}
		
		if (is_invalid){
			for (var j = 0; j < i; ++j){
				primitive_array[j].free();
				delete primitive_array[j];
			}
			Exception.throw_conditional(string_ext("failed to build mesh, invalid primitive [{0}].", [i]));
			return undefined;
		}

		// Add each primitive to the mesh and attach the material index
		mesh = new Mesh();
		mesh.hash = mesh_hash;
		mesh.matrix_import = transform;

		for (var i = 0; i < count; ++i)
			mesh.add_primitive(primitive_array[i], json_header.meshes[mesh_index].primitives[i][$ "material"] ?? -1);

		add_child_ref(mesh);
		return mesh;
	}
	
	/// @desc	This will generate a Model that contains all the Mesh and Primitives
	///			defined in the file, along with their respective materials. 
	///	@note	If possible, make sure your models are exported with all transforms applied!
	///			Manually applying them upon load is slow but may be necessary for duplicated meshes.
	/// @note	Models ARE NOT RESOURCE MANAGED, meaning that the model returned MUST be manually freed!
	///			The resources auto-generated and attached to the model itself, however, will be auto-managed
	///			by the system.
	/// @note	If an invalid scene is defined then EVERY MESH will be added to the model!
	///	@param	{real}			scene				Which scene from the model to generate a model from (-1 all meshes, regardless of scene)
	/// @param	{bool}			materials			Whether or not to generate materials for the model (Material indices will still be set)
	/// @param	{bool}			apply_transforms	Whether or not node transforms should be applied to the primitives
	/// @param	{VertexFormat}	vformat				VertexFormat to generate with, will attempt to fill missing data
	function generate_model(scene=-1, generate_materials=true, apply_transforms=true, format=undefined){
/// @stub	Implement support for custom formats (requires dynamic shader attributes on Windows)
		if (not is_undefined(format))
			throw new Exception("custom formats not yet supported!");
		else
/// @stub	Add proper format auto-calc as appropriate once implemented
			format = get_primitive_format(-1, -1);
		
		var model_hash = md5_string_utf8($"{self.load_directory}{self.name}_model_{format.get_hash()}{generate_materials}{apply_transforms}");
		var model = U3DObject.get_ref_data(model_hash);
		if (not is_undefined(model))
			return model;
		
		set_data(["model_data", "minimum"], undefined);
		set_data(["model_data", "maximum"], undefined);
		
		// Determine which nodes are in our scene:
		var node_array = get_scene_nodes(scene);
		
		count = array_length(node_array);
		
		// Add meshes based off of the nodes in the scene
		var mesh_struct = {};
		var is_invalid = false;
		var i;
		for (var i = 0; i < count; ++i){
			var node = json_header[$ "nodes"][node_array[i]];
			if (is_undefined(node[$ "mesh"])) // Not a mesh node
				continue;
			
			var mesh_id = node[$ "mesh"];
			if (not is_undefined(mesh_struct[$ mesh_id])) // Already defined
				continue;
			
/// @stub	Determine the format correctly per-mesh
			var mesh = generate_mesh(mesh_id, format, apply_transforms);
			if (is_undefined(mesh)){
				is_invalid = true;
				break;
			}
			
			mesh_struct[$ mesh_id] = mesh;
		}
		
		if (struct_names_count(mesh_struct) <= 0) // No meshes in the model
			return undefined;
		
		if (is_invalid){
			var mesh_array = struct_get_values(mesh_struct);
			for (var j = array_length(mesh_array) - 1; j >= 0; --j){
				mesh_array[j].free();
				delete mesh_array[j];
			}
			Exception.throw_conditional(string_ext("failed to build model, invalid mesh [{0}].", [i]));
			return undefined;
		}
		
		model = new Model();
		
		// Generate model-specific meshes + transforms
		for (var i = array_length(node_array) - 1; i >= 0; --i){
			var node = get_structure(node_array[i], "nodes");
			if (is_undefined(node[$ "mesh"]))
				continue;

			var mesh_id = node[$ "mesh"];
			var matrix = get_node_transform(node_array[i]);
			if (matrix_is_identity(matrix))
				matrix = undefined; // Prevents needless multiplications when rendering
				
			var mesh = mesh_struct[$ mesh_id].duplicate();
			
			// If applying transforms directly to vertices, we need to UNDO that for the
			// mesh transform since each mesh will needs its own special offset.
			if (not is_undefined(matrix) and not is_undefined(mesh.matrix_import))
				matrix = matrix_multiply(matrix_inverse(mesh.matrix_import), matrix);
			
			mesh.generate_unique_hash();
			mesh.matrix_model = matrix;
			model.add_mesh(mesh);
		}
			
		model.set_data(["import", "aabb_min"], get_data(["model_data", "minimum"]));
		model.set_data(["import", "aabb_max"], get_data(["model_data", "maximum"]));
		model.hash = model_hash;
		add_child_ref(model);
		
		if (not generate_materials)
			return model;
			
		// Add materials:
		var material_array = generate_material_array();
		for (var i = 0; i < array_length(material_array); ++i)
			/// @note	We mark the material as dynamic so it will auto-free w/ the model and release the textures as needed.
			model.set_material(material_array[i], i);
		
		return model;
	}
	
	/// @desc	Given an animation track name or animation track index and a skin,
	///			attempts to generate an AnimationTrack.
	/// @warning	The generated AnimationTrack MUST be manually freed when no longer
	///				needed! All sub-structures, such as AnimationGroup, will be freed
	///				along with the AnimationTrack
	function generate_animation_track(name_or_index, skin=0){
		if (is_undefined(json_header[$ "animations"]))
			return undefined;
			
		if (is_undefined(json_header[$ "skins"]))
			return undefined;
			
		if (skin < 0 or skin >= array_length(json_header[$ "skins"]))
			return undefined;
			
		#region FETCH ANIMATION HEADER
		var animation_data = undefined;
		var animation_name = "";
		if (is_string(name_or_index)){
			animation_name = name_or_index;
			var animation_array = json_header[$ "animations"];
			for (var i = array_length(animation_array) - 1; i >= 0; --i){
				if ((animation_array[i][$ "name"] ?? "") == name_or_index){
					animation_data = animation_array[i];
					break;
				}
			}
		}
		else if (is_numeric(name_or_index)){
			name_or_index = floor(name_or_index);
			var animation_array = json_header[$ "animations"];
			if (name_or_index < 0 or name_or_index >= array_length(animation_array))
				throw new Exception($"invalid track index [{name_or_index}], expected range is [0, {array_length(animation_array)})");
			
			animation_data = animation_array[name_or_index];
			animation_name = (animation_data[$ "name"] ?? string($"track_{name_or_index}"));
		}
		else
			throw new Exception("invalid type, expected [string] or [int]!");
		
		if (is_undefined(animation_data))
			throw new Exception($"invalid track, [{name_or_index}]");
		#endregion
		
		// Quick array key look-ups:
		var track_type = ["translation", "rotation", "scale"];
		var lerp_type = ["STEP", "LINEAR", "CUBICSPLINE"]; /// @note	CUBICSPLINE is UNSUPPORTED and will throw an exception!
		var skin_data = json_header.skins[skin];
		var joint_array = skin_data.joints;	// Contains node IDs that represent bone transforms
		var joint_count = array_length(joint_array);
		var channel_array = animation_data.channels;		// 1 channel = bone morphs for a single bone
		var channel_count = array_length(channel_array);
		var sampler_array = animation_data.samplers;
		var animation_track = new AnimationTrack(animation_name);
		var channelgroup_struct = {};	// Contains a channel group for each bone
		
		// Loop through each bone and collect all morphs for that bone:
		for (var i = 0; i < channel_count; ++i){
			var channel = channel_array[i];
			var sampler = sampler_array[channel.sampler];
			var bone_id = -1;
			
			// Calculate the bone id from the channel node:
			bone_id = array_get_index(joint_array, channel.target.node);
			
			// If the bone_id is not found then it is likely pointing to a node that ISN'T a bone.
			// This could be a mesh or anything else (which we don't support).
			if (bone_id < 0){
/// @todo (?)	Implement caching these node IDs and determine which mesh they may attach to (can be ancestrial)
///				to provide a way to attach the mesh to the animation tree?
				print_traced("WARNING", $"invalid channel node id [{channel.target.node}]; animation pointing to mesh instead of bone?");
				continue;
			}
			
			// Grab / Define channel group:
			var channel_group = (channelgroup_struct[$ bone_id]);
			if (is_undefined(channel_group)){
				channel_group = new AnimationChannelGroup();
				channelgroup_struct[$ bone_id] = channel_group;
			}
			
			var ttype = array_get_index(track_type, channel.target.path); // Correlates to BONE_PROPERTY_TYPE
			var ltype = array_get_index(lerp_type, sampler.interpolation); // Correlates to LERP_METHOD

			var animation_channel;
			if (ttype == 0)
				animation_channel = new AnimationChannelPosition();
			else if (ttype == 1)
				animation_channel = new AnimationChannelRotation();
			else if (ttype == 2)
				animation_channel = new AnimationChannelScale();
			else
				throw new Exception($"invalid animation channel path, [{channel.target.path}]!");
				
			animation_channel.generate_unique_hash();	// Make sure things are auto-cleaned w/ the AnimationTrack
			channel_group.set_channel(animation_channel); // Auto-sorts into position, rotation, or scale
			
			var time_range = read_accessor(sampler.input);
			var morph_range = read_accessor(sampler.output);
			var count = json_header.accessors[sampler.input].count;
			
			// Read each channel morph and add it to the channel:
			for (var j = 0; j < count; ++j)
				animation_channel.add_morph(time_range[j], morph_range[j], ltype);

			animation_channel.freeze();
		}	
		
		var group_keys = struct_get_names(channelgroup_struct);
		for (var i = array_length(group_keys) - 1; i >= 0; --i){
			var group = channelgroup_struct[$ group_keys[i]];
			group.generate_unique_hash();
			animation_track.add_channel_group(group, group_keys[i]);
		}
		
		return animation_track;
	}
	
	/// @desc	Generates an animation tree containing all recognized animation
	///			tracks! If an animation track does not have a name, it will be assigned
	///			the name "track_<index>" where <index> is the index number of the track.
	///	@warning	The AnimationTree generated MUST be manually freed! All animation tracks
	///				and morphs generated will be freed automatically along with the tree.
	/// @param	{real}	skin		the skin index to use when generating the animation tracks and skeleton
	function generate_animation_tree(skin=0){
		var track_count = get_animation_track_count();
		if (track_count <= 0)
			return undefined;
			
		var animation_tree = new AnimationTree();
		for (var i = 0; i < track_count; ++i){
			var track = generate_animation_track(i, skin);
			if (is_undefined(track)){
				Exception.throw_conditional($"failed to generate animation track [{i}]");
				continue;
			}
			
			track.generate_unique_hash();
			animation_tree.add_animation_track(track);
		}
		
		animation_tree.set_skeleton(generate_skeleton(skin));
		return animation_tree;
	}
	
	/// @desc	Generates a bone relational struct. Does NOT contain transform data
	///			apart from the inverse bone matrices.
	function generate_skeleton(skin){
		var skin_data = get_structure(skin, "skins");
		if (is_undefined(skin_data))
			throw new Exception($"invalid skin index [{skin}]");
		
		var joint_array = skin_data.joints;
		var joint_count = array_length(joint_array);
		var matrix_inv_array = read_accessor(skin_data.inverseBindMatrices);
		
		var skeleton = {};
		// Generate bone data child relations w/o parent relations
		for (var i = 0; i < joint_count; ++i){
			var child_array = [];
			var parent_id = -1;
			
			var node = json_header.nodes[joint_array[i]];
			// Grab the child node indices:
			child_array = (node[$ "children"] ?? []);
			
			// Convert node indices into bone indices:
			for (var j = array_length(child_array) - 1; j >= 0; --j){
				var node_index = child_array[j];
				child_array[j] = array_get_index(joint_array, node_index);
			}
			
			skeleton[$ i] = {
				parent_id : -1,						// Parent bone index (calculated below)
				child_id_array : child_array,		// Array of bone indices
				matrix_inv : matrix_inv_array[i],	// Inverse matrix to transform to world
				name : node[$ "name"]				// String name of bone (optional)
			}
		}
		
		// Generate parent relations:
		for (var i = 0; i < joint_count; ++i){
			var bone = skeleton[$ i];
			var child_array = bone.child_id_array;
			for (var j = array_length(child_array) - 1; j >= 0; --j){
				var child_id = child_array[j];
				var data = skeleton[$ child_id];
				if (is_undefined(data))
					throw new Exception("unsupported skeletal binding; [bone to node]!"); // Not connecting to another bone
					
				data.parent_id = i;
			}
		}
		
		return skeleton;
	}
	
	/// @desc	Generates an array of lights included in the scene data. This requires that
	///			the model has the KHR_lights_punctual extension specified. 
	/// @note	Lights ARE NOT RESOURCE MANAGED, meaning that the array of lights returned MUST be
	///			manually freed!
	/// @param	{real}	scene		scene to spawn lights from or -1 for all lights in the model
	/// @return {array}	of Light instances
	function generate_lights(scene=-1){
		if (not get_has_extension("KHR_lights_punctual"))
			return [];

		if (is_undefined(json_header[$ "extensions"]))
			return [];
		
		var light_array = json_header.extensions[$ "KHR_lights_punctual"];
		if (is_undefined(light_array))
			return [];
		
		light_array = light_array.lights;
		var node_array = get_scene_nodes(scene);
		var array = [];
		
		// Scan nodes and generate lights:
		for (var i = array_length(node_array) - 1; i >= 0; --i){
			var node = get_structure(node_array[i], "nodes");
			if (is_undefined(node[$ "extensions"]))
				continue;
			
			if (is_undefined(node.extensions[$ "KHR_lights_punctual"]))
				continue;
			
			var light_id = (node.extensions.KHR_lights_punctual[$ "light"] ?? -1);

			if (light_id < 0 or light_id >= array_length(light_array)) // Invalid light index
				continue;
			
			var light = light_array[light_id];
			var light_instance;
			switch (light.type){
				case "directional":
					var transform = get_node_transform(node_array[i]);
					var rotation = quat_reverse(quat_normalize(matrix_get_quat(transform)));
					rotation = quat_rotate_vec(rotation, vec(0, 0, -1));	// glTF specifies lights point down -Z, not +X like in U3D, so we rotate
					
					var translation = matrix_get_translation(transform); // Technically should be ignored, but including for shadow mapping
					light_instance = new LightDirectional(vec_to_quat(rotation), translation);
					light_instance.set_intensity((light[$ "intensity"] ?? 683) / 683);
				break;
				
				case "point":
					var transform = get_node_transform(node_array[i]);
					var translation = matrix_get_translation(transform);
					light_instance = new LightPoint(translation);
/// @fixme	Figure out correct lighting conversion; ATM this looks good enough
					light_instance.set_intensity((light[$ "intensity"] ?? 683) / 683);
					light_instance.set_range(light[$ "range"] ?? infinity);
				break;
				
				default:
					print_traced("WARNING", $"unsupported light type [{light.type}], skipping...");
				continue;
			}
			
			if (not is_undefined(light[$ "color"]))
				light_instance.set_color(make_color_rgb(255 * light[$ "color"][0], 255 * light[$ "color"][1], 255 * light[$ "color"][2]));

			array_push(array, light_instance);
/// @stub	Implement spot lights
		}
		
		return array;
	}
	
	/// @desc	Generates an array of cameras included in the scene data. The cameras generated
	///			will be CameraView types that cover the whole screen as glTF doesn't include
	///			viewport data.
	/// @note	Cameras ARE NOT RESOURCE MANAGED, meaning that the array of cameras returned MUST be
	///			manually freed!
	function generate_cameras(scene=-1){
		var node_array = get_scene_nodes(scene);
		var array = [];
		for (var i = array_length(node_array) - 1; i >= 0; --i){
			var node = json_header[$ "nodes"][node_array[i]];
			if (is_undefined(node[$ "camera"]))
				continue;
			
			var camera_id = node[$ "camera"];
			var camera_header = get_structure(camera_id, "cameras");
			if (is_undefined(camera_header))
				continue;
			
			var camera = new CameraView();
			if (camera_header[$ "type"] == "perspective"){
				var eye_header = camera_header[$ "perspective"];
				var eye = camera.get_eye();
				eye.set_znear(eye_header[$ "znear"]);
				eye.set_zfar(eye_header[$ "zfar"] ?? (eye_header[$ "znear"] + 1024));	// glTF says to specify infinity; not doing that
				
				/// @note	We work in xfov which auto-calculates the yfov. If we're given
				///			an aspect ratio then we attempt to reverse-calculate the xfov. If not,
				///			we just leave the xfov at the default.
				if (not is_undefined(eye_header[$ "aspectRatio"])){
					var aspect = eye_header[$ "aspectRatio"];
					var yfov = eye_header[$ "yfov"];

					var xfov = radtodeg(arctan(tan(yfov * 0.5) / aspect)) * 2.0;
					eye.set_fov(xfov);
				}
			}
			else if (camera_header[$ "type"] == "orthographic"){
				var eye_header = camera_header[$ "orthographic"];
				var eye = new EyeOrthographic(camera);
				eye.set_znear(eye_header[$ "znear"]);
				eye.set_zfar(eye_header[$ "zfar"] ?? (eye_header[$ "znear"] + 1024));	// glTF says to specify infinity; not doing that
				eye.set_size(
					eye_header[$ "xmag"] * 2.0,
					eye_header[$ "ymag"] * 2.0
				);
				camera.set_eye(eye);	// Replace the default eye with the new orthographic version
			}
			
			/// @note	We DON'T support the camera being transformed by other nodes! The camera
			///			only uses it's local rotation / translation values.
			var pos = node[$ "translation"];
			var rotation = node[$ "rotation"];
			if (is_undefined(pos) or is_undefined(rotation)){
				Exception.throw_conditional("unsupported camera node transform type, [Matrix]!");
				continue;
			}
			
			rotation = quat(rotation[0], rotation[1], rotation[2], rotation[3]);
			
			camera.set_position(vec(pos[0], pos[1], pos[2]));
			camera.set_rotation(rotation);
			
			// Due to our camera looking down +X instead of -Z, we rotate to match the difference
			var up = camera.get_up_vector();
			var left = vec_reverse(camera.get_right_vector());
			camera.look_at_up(vec_add_vec(camera.get_position(), left), up);
			array_push(array, camera);
		}
		
		return array;
	}
	#endregion
	
	#region INIT
	// Auto-load in the model:
	if (not load(name, directory)){ // Will auto-throw if the file doesn't exist
		if (not string_ends_with(directory, "/") and not string_ends_with(directory, "\\") and directory != "")
				directory += "/";
				
		throw new Exception(string_ext("failed to load file [{0}]!", [directory + name]));
	}
	#endregion
}