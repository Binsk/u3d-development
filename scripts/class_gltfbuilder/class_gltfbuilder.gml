/// @about
/// The GLTFBuilder is an extension of the GLTFLoader that provides functions for
/// constructing in-game meshes, materials, and the like out of the buffer data
/// contained within. Unless you are doing something very specific or custom, 
/// you should load in GLTF / GLB files with this rather than the GLTFLoader().
///
/// All structures generated by the builder must be MANUALLY freed and destroyed,
/// otherwise it will cause a memory leak.
///
/// @note	The GLTFBuilder does NOT support the full glTF spec and all of its
///			nuances. It was designed to handle general-case usage of Blender exports.

function GLTFBuilder(name="", directory="") : GLTFLoader() constructor {
	#region PROPERTIES
	#endregion
	
	#region METHODS
	/// @desc	Returns the total number of meshes in the loaded model.
	function get_mesh_count(){
		return array_length(json_header[$ "meshes"] ?? []);
	}
	
	/// @desc	Given a mesh index in the file, returns the number of primitives
	///			required to define the mesh.
	function get_primitive_count(mesh_index){
		if (not in_range(mesh_index, 0, get_mesh_count() - 1)) // Invalid mesh
			return 0;
		
		return array_length(json_header.meshes[mesh_index][$ "primitives"] ?? []);
	}
	
	/// @desc	Given a primitive, generates a VertexFormat that will correctly
	///			contain all the data specified by the model file.
	function get_primitive_format(mesh_index, primitive_index){
/// @stub implement
	}
	
	/// @desc	Given a mesh and primitive index, attempts to generate a Primitive.
	///			The Primitive will contain the properties specified according to the 
	///			specified format. If the format contains values that are undefined by the
	///			model, the system will attempt to generate them (if possible) or fill them
	///			with 0 values. Returns 'undefined' if an error occurred.
	/// @param	{int}	mesh_index				index of the mesh to read from
	/// @param	{int}	primitive_index			index of the primitive to generate
	/// @param	{VertexFormat} vertex_format	vertex format to specify data layout and inclusion
	function generate_primitive(mesh_index, primitive_index, format) {
		if (not in_range(mesh_index, 0, get_mesh_count() - 1))	// Invalid mesh index
			return undefined;
		
		if (not in_range(primitive_index, 0, get_primitive_count(mesh_index) - 1)) // Invalid primitive index
			return undefined;
		
		if (not is_instanceof(format, VertexFormat)){
			Exception.throw_conditional("invalid type, expected [VertexFormat]!");
			return undefined;
		}
		
		// Fetch our primitive header so we know what data we have:
		var primitive_header = json_header.meshes[mesh_index].primitives[primitive_index];
			// Check topology, we only support one type of many:
		if ((primitive_header[$ "mode"] ?? 4) != 4){
			var mode_labels = ["POINTS", "LINES", "LINE_LOOP", "LINE_STRIP", "TRIANGLES", "TRIANGLE_STRIP", "TRIANGLE_FAN"];
			Exception.throw_conditional(string_ext("unsupported topology type [{0}], expected [{1}]!", [mode_labels[primitive_header[$ "mode"] ?? 4], mode_labels[4]]));
			return undefined;
		}

		var accessor_index = primitive_header.indices;
		if (is_undefined(accessor_index)){ // We only support index definition through accessors
			Exception.throw_conditional("unsupported primitive definition, indices accessor required!");
			return undefined;
		}
		
		// Grab the accessor so we can fetch a list of vertex indices
		var primitive_accessor = get_structure(accessor_index, "accessors");
		if (is_undefined(primitive_accessor)){
			Exception.throw_conditional(string_ext("invalid accessor index [{0}]!", [accessor_index]));
			return undefined;
		}
		if ((primitive_accessor[$ "type"] ?? "UNKNOWN") != "SCALAR"){
			Exception.throw_conditional(string_ext("unsupported index type [{0}], expected type [SCALAR].", [primitive_accessor[$ "type"] ?? "UNKNOWN"]));
			return undefined;
		}
		
		var vertex_index_array = read_accessor(accessor_index); // Array if integers pointing to vertex data indices
		if (is_undefined(vertex_index_array)){ // If anything goes wrong, throw a generic error
			Exception.throw_conditional(string_ext("failed to read accessor [{0}]!", [accessor_index]));
			return undefined;
		}

		#region BUILD ATTRIBUTE LOOKUP
		// Now we bulid array groups of attributes that match the vertex format for quick look-up
		// when building the mesh
		var vertex_index_count = array_length(vertex_index_array);
		var missing_data = [];	// Record which data is missing so we can spit a warning
		var primitive_map = {};
		for (var i = array_length(format.vformat_array) - 1; i >= 0; --i){
			var array;
			var format_label = VertexFormat.get_vertex_data_gltf_label(format.vformat_array[i]);
			var accessor_index = primitive_header.attributes[$ format_label];
			
			if (is_undefined(accessor_index)){ // Mesh doesn't contain data we are requesting; fill w/ defaults
				array = array_create(vertex_index_count, VertexFormat.get_vertex_data_default(format.vformat_array[i]));
				array_push(missing_data, format_label);
			}
			else
				array = read_accessor(accessor_index);
			
			primitive_map[$ format_label] = array;
		}
		#endregion
		
		if (array_length(missing_data) > 0)
			print_traced("WARNING", "primitive definition missing requested data ", string_replace_all(json_stringify(missing_data, false), "\"", ""));
		
		// Build the primitive itself:
		var primitive = new Primitive(format);
		primitive.define_begin();
		for (var i = array_length(format.vformat_array) - 1; i >= 0; --i){
			var format_label = VertexFormat.get_vertex_data_gltf_label(format.vformat_array[i]);
			var array = primitive_map[$ format_label];
			for (var j = 0; j < vertex_index_count; ++j){
				var data = array[vertex_index_array[j]];
/// @stub	handle tangents being vec(0,0,0) (aka., unset) and auto-calculate them
				primitive.define_add_data(format.vformat_array[i], data);
			}
		}
		primitive.define_end();
		return primitive;
/// @stub	Implement
	}
	#endregion
	
	#region INIT
	// Auto-load in the model:
	if (not load(name, directory)){ // Will auto-throw if the file doesn't exist
		if (not string_ends_with(directory, "/") and not string_ends_with(directory, "\\") and directory != "")
				directory += "/";
				
		throw new Exception(string_ext("failed to load file [{0}]!", [directory + name]));
	}
	#endregion
}